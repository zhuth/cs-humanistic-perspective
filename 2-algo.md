人文观点下的计算机科学引论
=============
Computer Science in a Humanistic Perspective: A Brief Introduction

## 数据结构与算法分析

### 引言

休息一周，我们来继续“作为人类语言的 Python 导论”未完成的部分。在“导论”引导下学习了 Python 语言之后，应该可以完成诸如给出若干不同功能的片段，然后把它们组装成一个脚本用于自己的目的这样的工作，而这实际上涵盖了大部分我们日常中可能用到 Python 的情形。

但是，如果我们试图走得更深一些，或者就像“导论”中所说的那样，用 Python 作为一种语言来认识世界上的一些事物，理解一群人的话，我们可能需要一种更激进的观点，把计算机科学视为一种人文学科看待。

计算机科学作为人文学科的意义是：它最终实际上也就是为了增进人之间的理解。这种特性不是由于它关涉硬件的部分，而是由于它的程序，它关涉到数学的部分。

数学问题的求解是对一个不清晰的问题换用一种清晰的、完善定义了的方式来回答。譬如我们说，鸡兔同笼问题中的鸡有 $x$ 只而兔有 $y$ 只，并列出方程如 $x + y = 35$ 且 $2x + 4y = 94$，这时（可以证明）$x$ 与 $y$ 都是唯一的，因此我们也可以说“鸡兔同笼问题中，鸡的数量是如上定义的 $x$，兔的数量是如上定义的 $y$”。但是这个问题本身作为对 $x$ 和 $y$ 的描述太过冗长，未若 $x = 23$ 而 $y = 12$ 者。数学家的工作可以看做不断完善这种描述的语言，并将一种形式的描述转换成另一种形式。我们可以说他们的工作，就这个层面而言，是句法的。数学并未因此关涉到任何一种客观实在——那将是（在各种意义上的）物理学的工作——而作为一种语言的运用，它就是人文的。相反，各种意义上的物理学，作为严格的自然科学，乃是要用语言，包括数学的语言，去逼近现实。一种物理的理论可以描述和（哪怕是极其有限地）预测现实。而一种数学的理论是一种句法，是数学语言自我产生的方式。

计算机科学建立在数学的基础上，并且如我们所见，它有自己的语言。它没有要用现成语言逼近现实的冲动，而是像数学那样更多地表现出规定性。何以 1 + 1 = 2？这是由于人们的规定。谈论“1”到底“是什么”是没有意义的，而说“1”只有在一个数学的系统之中有意义，也就是说它实际上只有句法的意义，正如“我”这个词一样。

因而计算机科学可以视为（1）被数学规定的部分和（2）自身作出规定的部分的融合。算法分析与数据结构也就分别属于这两个部分。不过既然我们在标题中说“人文观点”，为照顾这个词通常狭窄含义，我们就不可能对算法分析中的数学作出深入的讲解。作为这个系列的第一篇，不妨直奔主题，先将算法分析的部分作个简单的交代。

### 什么是算法

解决某一问题的确定而可操作的步骤。

- 问题：如何把大象塞进冰箱？
- 步骤 1：打开冰箱门
- 步骤 2：把大象搬进去
- 步骤 3：关上冰箱门



- 问题：如何找出房间里的大象？
- 步骤 1：呼唤大象
- 步骤 2：等待回应
- 步骤 3：如果没有等到回应，告知“没有大象”



- 问题：如何求雨？
- 步骤 1：请神（仪式步骤另附）
- 步骤 2：念咒（咒语另附），在念咒时不要想到大象
- 步骤 3：送神

### 最初的符号，最后的意义

算法分析要做什么？简单地来说，我们主要做时间复杂度分析和空间复杂度分析，两者中又以前者为主要。计算机作为某种物质性的同时也是 *ästhetische* 的东西（在这个词的哲~学意义上），必然要求了时间和空间两种“感性直观的纯形式”（KrV: A22/B36），我们的分析从作为人的角度来说也就只能限制在这两个范围之内。时间之所以重要，从实用的角度来说，是因为我们哪怕再有钱，拥有最高级的设备，也无法可观地减少运行所用的实际时间，而一个好的算法则可以仅仅凭其本性而为我们节省下不少的时间，毕竟人生苦短（所以要用 Python 对不对）。而空间的复杂度还在于，我们不仅没有大把大把的时间，我们还缺钱。所以如果能减少内存的占用量或其它相关存储和通信资源，我们还可以省下一笔钱。算法分析在这个意义上就为我们选择使用何种方法提供了参考。

但从根本上，算法分析的意义在于，帮助你自己写出更好或更合适的代码。在远古时代人们并没有 `List.sort()` 之类的方法实现排序，而需要诸如自己去写一个排序函数。这时候你就要看了，如果时间紧而任务简单，列表固定只有 10 个数值，写一个冒泡排序就打发了；而列表的长度成千上万，对不起，请你还是写一个快速排序吧。因而进行算法分析，对于我们从程序编写入手的人（而不是理论的建构者）来说，就是理解程序代码的时间、空间代价。只有意识到这些代码不是免费的咒语，而是实实在在地蕴含了运行时的代价，编写代码的“认真”态度才有了用武之地，否则就只是一种姿态而已。

#### 符号

- f(x) —— 一个关于 x 的函数
- f(x) = O(g(x)) —— 我们在此只需知道，它的意思表示，f(x) 随着 x 的增长而变化的“速度”，不会超过 g(x) 随 x 增长而变化的“速度”相同。在算法分析的语境中，这些函数 f、g 可以认为都是随着自变量 x 的增长而增长的，因为 x 常常代表了问题的规模。
- 问题的规模 —— 使用算法求解的问题的一个量化的指标，譬如，冰箱的大小和大象的体重。

#### 公式

- O(f(x) + g(x)) = max(O(f(x)), O(g(x)))
- O(f(x)·g(x)) = O(O(f(x))·O(g(x)))
- n² + n + 1 = O(n²) —— 一般地，最高为 k 次方的多项式 P(k)（希望你还没有忘记这个中学数学的概念）= O(nk)
- O(c) = 1（c 为常数）
- 由上可知，O(cf(x)) = O(f(x))

#### 常用的顺序：

O(c) “<” O(log n) “<” O(logk n) “<” O(n) “<” O(nk) \[随 k 增大而越“大”\] “<” O(cn) \[随常数 c 增大而越“大”\]

这里的小于号都加了引号，是因为我们实际上无法这样给若干个 O 记号作比较。从数学上说，合适的符号是“=”，因为我们前面的定义中并没有说 O 记号括号里的公式必须最为接近原来的那个式子 f，而只说“不超过”，尽管要想得出有用的分析，我们总得尽可能得出接近的式子。

### 面向代码

#### 循环的时间复杂度

算法分析经常从 for 循环入手，因为它的次数通常来说最方便。考虑如下 Python 代码片段：

```python
s = 0
for _ in range(0, 100):
	s += _
```

`for` 循环内部给 `x` 自加的步骤执行了 `100` 次（`_` 取 `0` 到 `99`），因此我们可以说上面这段代码的时间复杂度是 O(100) = O(1) 。

啊，对，因为我们在这里并没有可变的“问题的规模”。
我们修改一下代码，再试一次：

```python
s = 0
for _ in range(0, n):
	s += _
```

上述代码，自加的步骤执行了 n 次，n 是我们这里的“问题的规模”。所以上述代码的时间复杂度是 O(n)。

但如果我们的问题是求 1 到 2n 的和，上述代码写成

它的时间复杂度仍然是 O(n)。

接下来，考虑如下嵌套的循环：

看起来复杂很多。我们先看里面一个关于 x 的循环，无论怎样运行，这个循环内部的指令数量都与问题的规模无关。因此它就可以看做一个常数项，而所有的常数我们都可以看作 1。于是内部这个关于 x 的循环时间复杂度是 O(maxx + 1) = O(maxx)。

再看外面关于 y 的循环，它包含了两条（因此也是常数项）语句和一个 for 循环，因此它的时间复杂度，也就是整个这个代码片段的时间复杂度为：O(maxy * (O(maxx) + 1)) = O(maxy * maxx) 。

从上述观察我们可以看出，多重循环的时间复杂度，通常就是各级循环迭代规模相乘——除非，在某一级中调用到了一个复杂度超过其内部循环的函数之类。比如：

在这里，我们假设 mat 是一个 n×w 的矩阵而 w 总是大于 m，并假设 sum 函数的时间复杂度为相对其规模是线性的（即，如果规模是 n，它就是 O(n)；此 n 非彼 n），因此就是 O(w) 。而根据 O(w + m) = max(O(w), O(m)) ，x 的循环体内部时间复杂度就是 O(w) 而不是 O(m)，因此整个片段的时间复杂度就是 O(nw) 而不是 O(nm)。

递归程序的复杂度分析
嗯哼，这是一个非常有趣的问题。
比如说下面这个代码片段计算著名的斐波那契数列：

如果用 T(n) 表示取某个值 n 时上述代码所需进行的基本操作数量，我们会有：
T(n) = T(n - 1) + T(n - 2) + c

显然 T(n) > Fib(n) （Fib 表示“数学上的”斐波那契数列）
我们知道，斐波那契数列的通项公式是

因此 Fib(n) = O(cn)，c = (1 + √5) / 2 < 2。
而，做一些扩大，我们有 T(n) ≤ 2T(n - 1) + c
忽略常数项，我们可以有 T(n) ≤ 2n 。即 T(n) = O(2n)
Fib(n) < T(n) = O(2n)
所以上面这个 fib 代码怎么看都逃不掉是一个指数级别的时间复杂度了。

相反，如果我们可以在常数时间内计算出一个数的任意次方（在浮点数允许的范围内，我们确实可以！），直接用上面的通项公式计算斐波那契数列，时间复杂度将是——
O(1)
你看，于是我们如果知道了通项公式，不用花很多时间很多钱，就可以算出比如 Fib(1000)，而用上面的 fib 这个函数则要花许许多多的时间。指数增加是极其可怕的。但不幸的是，我们恐怕并不总是那么幸运，可以有一个别人已经算好了的通项公式来用，而且有时确实也算不出这样一个通项公式来。

在运行时节省下来的时间，是我们为之付出的脑力——和时间——给它买了单。

数据结构

我们将在后面讲解数据结构的时候运用到一些关于算法分析的内容，这将为我们展现出，人们为什么要去发明这样一种数据结构。但首先恐怕还是要明确一下，数据结构大致上是什么？

不要把它和数据库搞起来。数据结构指的是数据的组织方式。它尽管常常可以用 Python 里的“类”来实现，却不是“类”这个概念本身：重要的是数据之间关联的结构，而不是数据自身有什么样的结构。因此，“学生”有“姓名”、“学号”和“成绩”，这不是数据结构考察的内容；数据结构考察怎样将这些信息排列起来，例如存成链表，还是依照学号存成一个二叉树，而这将决定我们访问这些学生信息的效率。

但是，毕竟在运用 Python 实现具体的数据结构时，我们常常利用“类”。这些类除了种种数据之外，额外地包含了描述某种数据结构所要求的数据间关系的信息。

今天我们就讲一个非常简单的，也是大家的老朋友了——链表。我们看到过链表是这个样子的：

后来我们又看到了双向链表：

这里，“next”和“prev”字段就属于上面所说的，单向和双向链表所要求的数据间关系。不过，我们其实还没有很好地定义一些操作，以将某个值插入到链表中某个节点的后面。我们在这里就先只实现一个单向链表的完整操作：


屏幕上将输出：

在这个过程中，我们发现，单向链表只能从头到尾地走一遍，因此保留一个“头”（head）就非常重要。这个“头”使我们得以几次三番从头再来。

我们还可以用下面的语句，寻找某个值 n 是否在链表中，如果存在的话就输出“Exists”：
LinkNode.iterate(head, lambda x: print('Exists') if x == n else 0)

而双向链表由于多了一个 prev 字段，就保留了前一个数据的位置信息（姑且这么说吧），所以不仅可以正过去，还可以倒过来。实现 DoubleLinkNode 的任务当然就交给诸君留作练习了。一并留作思考的是：上述寻找某数 n 的代码，其时间复杂度是多少？（将访问一个链表节点视为一个基本操作）

